// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collector

import (
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// A NelReport describes a single network error report.
//
// (The name is a bit of a misnomer; it can also represent other report payloads
// uploaded via the Reporting API, in which case ReportType will tell you what
// kind of report it is, and RawBody will contain the unparsed JSON `body`
// field.  It can also represent information about successful HTTP requests,
// collected and delivered via a user agent's NEL stack, in which case the Type
// field will be "ok".)
type NelReport struct {
	// The number of milliseconds between when the report was generated by
	// the user agent and when it was uploaded.
	Age int
	// The type of report.  For NEL, this will be "network-error".
	ReportType string
	// The URL of the request that this report describes.
	URL string
	// UserAgent represents the value of the User-Agent header in the request that the report is about
	UserAgent string
	// The referrer information of the request, as determined by the
	// referrer policy associated with its client.
	Referrer string
	// The active sampling rate for this request, expressed as a fraction
	// between 0.0 and 1.0 (inclusive).
	SamplingFraction float32
	// The IP address of the host to which the user agent set the request.
	ServerIP string
	// The ALPN ID  of the network protocol used to fetch the resource.
	Protocol string
	// The method of the HTTP request (e.g. GET, POST)
	Method string
	// The status code of the HTTP response, if available.
	StatusCode int
	// The elapsed number of milliseconds between the start of the resource
	// fetch and when it was aborted by the user agent.
	ElapsedTime int
	// The phase of the request in which the failure occurred. One of
	// {dns, connection, application}; a successful request always has a value of application
	Phase string
	// The description of the error type.  For reports about successful
	// requests, this will be "ok".  See the NEL spec for the authoritative
	// list of possible values for failed requests.
	Type string

	// For non-NEL reports, this will contain the unparsed JSON content of
	// the report's `body` field.
	RawBody []byte

	// An arbitrary set of extra data that you can attach to your reports.
	Annotations
}

type rawReport struct {
	Age        int             `json:"age"`
	ReportType string          `json:"type"`
	URL        string          `json:"url"`
	UserAgent  string          `json:"user_agent"`
	Body       json.RawMessage `json:"body"`
}

type nelReportBody struct {
	Referrer         string  `json:"referrer"`
	SamplingFraction float32 `json:"sampling_fraction"`
	ServerIP         string  `json:"server_ip"`
	Protocol         string  `json:"protocol"`
	Method           string  `json:"method"`
	StatusCode       int     `json:"status_code"`
	ElapsedTime      int     `json:"elapsed_time"`
	Phase            string  `json:"phase"`
	Type             string  `json:"type"`
}

// UnmarshalJSON unmarshals the JSON payload as defined by the Reporting and NEL
// specs into a NelReport object.  (It correctly handles the nested structure of
// the JSON, filling in the fields of the non-nested NelReport type.)
func (r *NelReport) UnmarshalJSON(b []byte) error {
	var raw rawReport
	err := json.Unmarshal(b, &raw)
	if err != nil {
		return err
	}
	r.Age = raw.Age
	r.ReportType = raw.ReportType
	r.URL = raw.URL
	r.UserAgent = raw.UserAgent

	if raw.ReportType == "network-error" {
		var body nelReportBody
		err = json.Unmarshal(raw.Body, &body)
		if err != nil {
			return err
		}
		r.Referrer = body.Referrer
		r.SamplingFraction = body.SamplingFraction
		r.ServerIP = body.ServerIP
		r.Protocol = body.Protocol
		r.Method = body.Method
		r.StatusCode = body.StatusCode
		r.ElapsedTime = body.ElapsedTime
		r.Phase = body.Phase
		r.Type = body.Type
	} else {
		r.RawBody = raw.Body
	}

	return nil
}

// MarshalJSON marshals a NEL report into a JSON payload as defined by the
// Reporting and NEL specs.  (It correctly handles the nested structure of the
// JSON, extracting the fields of the non-nested NelReport type.)
func (r NelReport) MarshalJSON() ([]byte, error) {
	var body []byte
	var err error
	if r.ReportType == "network-error" {
		body, err = json.Marshal(nelReportBody{
			Referrer:         r.Referrer,
			SamplingFraction: r.SamplingFraction,
			ServerIP:         r.ServerIP,
			Protocol:         r.Protocol,
			Method:           r.Method,
			StatusCode:       r.StatusCode,
			ElapsedTime:      r.ElapsedTime,
			Phase:            r.Phase,
			Type:             r.Type,
		})
		if err != nil {
			return nil, err
		}
	} else {
		body = r.RawBody
	}

	return json.Marshal(rawReport{
		Age:        r.Age,
		ReportType: r.ReportType,
		URL:        r.URL,
		UserAgent:  r.UserAgent,
		Body:       body,
	})
}

// ReportBatch is a collection of reports that should all be processed together.
// We will create a new batch for each upload that the collector receives.
// Certain processors might join batches together or split them up.
type ReportBatch struct {
	Reports []NelReport

	// When this batch was received by the collector
	Time time.Time

	// The URL that was used to upload the report.
	CollectorURL url.URL

	// The IP address of the client that uploaded the batch of reports.  You can
	// typically assume that's the same IP address that was used for the original
	// requests.  The IP address will be encoded as a string; for example,
	// "192.0.2.1" or "2001:db8::2".
	ClientIP string

	// The user agent of the client that uploaded the batch of reports.
	ClientUserAgent string

	// The key-value pairs of the HTTP header that is received by the collector.
	// This can be used to get additional information. One example is to get the
	// remote address of the client when the collector runs behind a proxy.
	Header http.Header

	// An arbitrary set of extra data that you can attach to this batch of
	// reports.
	Annotations
}

// NewReportBatch takes a HTTP request and a clock and fills in a ReportBatch,
// returning an error if parsing fails.
func NewReportBatch(r *http.Request, clock Clock) (*ReportBatch, error) {
	host, _, err := net.SplitHostPort(r.RemoteAddr)
	if err != nil {
		return nil, fmt.Errorf("net.SplitHostPort(%v): %v", r.RemoteAddr, err)
	}

	var reports ReportBatch
	reports.Time = clock.Now()
	reports.CollectorURL = *r.URL
	reports.ClientIP = host
	reports.ClientUserAgent = r.Header.Get("User-Agent")
	reports.Header = r.Header
	decoder := json.NewDecoder(r.Body)
	err = decoder.Decode(&reports.Reports)
	if err != nil {
		return nil, fmt.Errorf("decoder.Decode(&reports.Reports): %v", err)
	}
	return &reports, nil
}

// PrintBatchAsCLF prints out a summary of each report in the batch using a
// format not unlike the format of an Apache access.log file.
func PrintBatchAsCLF(batch *ReportBatch, w io.Writer) {
	time := batch.Time.UTC().Format("02/Jan/2006:15:04:05.000 -0700")
	for _, report := range batch.Reports {
		if report.ReportType == "network-error" {
			var result string
			if report.Type == "ok" || report.Type == "http.error" {
				result = strconv.Itoa(report.StatusCode)
			} else {
				result = report.Type
			}
			fmt.Fprintf(w, "%s - - [%s] \"GET %s\" %s -\n", batch.ClientIP, time, report.URL, result)
		} else {
			fmt.Fprintf(w, "%s - - [%s] \"GET %s\" <%s> -\n", batch.ClientIP, time, report.URL, report.ReportType)
		}
	}
}

// EncodeRawReports marshals an array of NelReports without using our custom
// spec-aware JSON parsing rules, instead dumping out the content exactly as it
// looks in Go.  This is used extensively in test cases to compare the results
// of parsing and annotating against golden files.
func EncodeRawReports(reports []NelReport) ([]byte, error) {
	// This type alias lets us override our spec-aware JSON parsing rules, and
	// dump out the content of a NelReport instance exactly as it looks in Go.
	type ParsedNelReport NelReport
	parsedReports := make([]ParsedNelReport, len(reports))
	for i := range reports {
		parsedReports[i] = (ParsedNelReport)(reports[i])
	}
	return json.MarshalIndent(parsedReports, "", "  ")
}

// DecodeRawReports unmarshals an array of NelReports without using our custom
// spec-aware JSON parsing rules.  It's the inverse of EncodeRawReports.
func DecodeRawReports(b []byte, reports *[]NelReport) error {
	// This type alias lets us override our spec-aware JSON parsing rules, and
	// dump out the content of a NelReport instance exactly as it looks in Go.
	type ParsedNelReport NelReport
	var parsedReports []ParsedNelReport
	err := json.Unmarshal(b, &parsedReports)
	if err != nil {
		return err
	}

	*reports = make([]NelReport, len(parsedReports))
	for i := range parsedReports {
		(*reports)[i] = (NelReport)(parsedReports[i])
	}
	return nil
}

// EncodeRawBatch marshals a batch of NelReports, including any custom
// annotations, without using our custom spec-aware JSON parsing rules.
func EncodeRawBatch(batch *ReportBatch) ([]byte, error) {
	var err error
	var rawBatch struct {
		*ReportBatch
		RawReports json.RawMessage `json:"Reports"`
	}

	rawBatch.ReportBatch = batch
	rawBatch.RawReports, err = EncodeRawReports(rawBatch.Reports)
	if err != nil {
		return nil, err
	}

	rawBatch.Reports = nil
	return json.MarshalIndent(rawBatch, "", "  ")
}
